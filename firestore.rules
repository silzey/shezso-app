/**
 * @file Firebase Security Rules for Firestore.
 *
 * @core_philosophy This ruleset enforces a strict user-ownership model for user-specific data
 * and allows public read access to posts, while restricting write access to the owner.
 *
 * @data_structure
 * - /users/{userId}: Stores user profile data.
 * - /posts/{postId}: Stores post data with public read access but owner-only write access.
 * - /dispensaries/{dispensaryId}: Stores dispensary information with public read access.
 * - /chats/{chatId}: Stores chat metadata. Access is restricted to chat participants.
 * - /chats/{chatId}/messages/{messageId}: Stores individual chat messages. Access is restricted to chat participants.
 * - /friendRequests/{toUserId}/requests/{fromUserId}: Stores friend request data.
 *
 * @key_security_decisions
 * - Users can only read and write their own user document.
 * - Posts are publicly readable, but only the owner can create, update, or delete them.
 * - Dispensaries are publicly readable.
 * - Chat access is restricted to participants in the chat.
 * - Friend requests can only be created if the authenticated user is the sender.
 *
 * @denormalization_for_authorization
 * - The `Post` entity MUST include a `userId` field to identify the owner.
 *
 * @structural_segregation Public vs Private: Publicly accessible posts are kept in a separate top-level collection (/posts/{postId})
 * to ensure scalability and security for read operations, while user-specific data remains under the /users/{userId} collection.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Secure access to user profiles.
     * @path /users/{userId}
     * @allow (create) Authenticated user can create their own profile if the userId matches their auth UID.
     * @allow (get, list, update, delete) Authenticated user can only access their own profile.
     * @deny (create) Unauthorized user attempts to create a profile with a mismatched userId.
     * @principle Enforces document ownership for user profiles.
     */
    match /users/{userId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
          return isOwner(userId) && resource != null;
      }

      allow create: if isSignedIn() && isOwner(userId) && request.resource.data.id == request.auth.uid;
      allow get, list: if isSignedIn() && isOwner(userId);
      allow update: if isSignedIn() && isExistingOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if isSignedIn() && isExistingOwner(userId);
    }

    /**
     * @description Secure access to posts.
     * @path /posts/{postId}
     * @allow (get, list) Publicly readable.
     * @allow (create) Authenticated user can create a post with their userId.
     * @allow (update, delete) Authenticated user can only update or delete their own posts.
     * @deny (create) Unauthorized user attempts to create a post with a mismatched userId.
     * @principle Enforces document ownership for posts, with public read access.
     */
    match /posts/{postId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner() {
        return resource.data.userId == request.auth.uid;
      }

        function isExistingOwner() {
          return isOwner() && resource != null;
      }

      allow get, list: if true;
        allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
        allow update: if isSignedIn() && isExistingOwner();
        allow delete: if isSignedIn() && isExistingOwner();
    }

     /**
      * @description Allows public read access to dispensaries.
      * @path /dispensaries/{dispensaryId}
      * @allow (get, list) Any user can read dispensaries.
      * @deny (create, update, delete) No one can create, update, or delete dispensaries.
      * @principle Provides public information about dispensaries.
      */
    match /dispensaries/{dispensaryId} {
      allow get, list: if true;
      allow create, update, delete: if false;
    }

    /**
     * @description Secure access to chat metadata.
     * @path /chats/{chatId}
     * @allow (get, list) Participants in the chat can read the chat metadata.
     * @allow (create) Users can create new chats where they are a participant.
     * @allow (update, delete) No one can update or delete chat metadata.
     * @deny (create) Unauthorized user attempts to create a chat without being a participant.
     * @principle Enforces chat participation for access control.
     */
    match /chats/{chatId} {
        function isSignedIn() {
          return request.auth != null;
        }

        function isParticipant() {
            return request.auth.uid in resource.data.participants;
        }

        function isCreatingParticipant() {
          return request.auth.uid in request.resource.data.participants;
        }

        allow get, list: if isSignedIn() && isParticipant();
        allow create: if isSignedIn() && isCreatingParticipant();
        allow update, delete: if false;
    }

    /**
     * @description Secure access to chat messages.
     * @path /chats/{chatId}/messages/{messageId}
     * @allow (get, list) Participants in the chat can read messages.
     * @allow (create) Participants in the chat can create new messages.
     * @allow (update, delete) No one can update or delete messages.
     * @deny (create) Unauthorized user attempts to create a message in a chat they don't participate in.
     * @principle Enforces chat participation for access control.
     */
    match /chats/{chatId}/messages/{messageId} {
        function isSignedIn() {
          return request.auth != null;
        }

        function isParticipant(chatId) {
          return request.auth.uid in get(/databases/$(database)/documents/chats/$(chatId)).data.participants;
        }

        allow get, list: if isSignedIn() && isParticipant(chatId);
        allow create: if isSignedIn() && isParticipant(chatId);
        allow update, delete: if false;
    }

    /**
     * @description Secure access to friend requests.
     * @path /friendRequests/{toUserId}/requests/{fromUserId}
     * @allow (create) Authenticated user can create a friend request to another user.
     * @allow (get) Only the recipient of the friend request can read it.
     * @allow (update) Only the recipient of the friend request can update it (accept or decline).
     * @deny (list, delete) No listing or deleting of friend requests allowed.
     * @principle Restricts friend request management to involved users.
     */
    match /friendRequests/{toUserId}/requests/{fromUserId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isSender(fromUserId) {
        return request.auth.uid == fromUserId;
      }

      function isRecipient(toUserId) {
        return request.auth.uid == toUserId;
      }

      allow create: if isSignedIn() && isSender(fromUserId);
      allow get: if isSignedIn() && isRecipient(toUserId);
      allow update: if isSignedIn() && isRecipient(toUserId);
      allow list, delete: if false;
    }

    /**
     * @description Secure access to the "post-its" subcollection under a user.
     * @path /users/{userId}/post-its
     * @allow (list) Authenticated user can only list their own post-its.
     * @principle Enforces document ownership for post-its in a user's subcollection.
     */
     match /users/{userId}/post-its/{postItId} {
        function isSignedIn() {
          return request.auth != null;
        }

        function isOwner(userId) {
          return request.auth.uid == userId;
        }

        allow list: if isSignedIn() && isOwner(userId);
        allow get, create, update, delete: if false;
     }
  }
}